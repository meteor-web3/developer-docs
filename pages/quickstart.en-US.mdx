import { Callout } from 'nextra-theme-docs';

# Getting started with Meteor SDK

A quick guide to get you started with the meteor runtime connector SDK.

After reading this guide, you will be able to connect with the meteor browser extension,
create, load, update and monetize a file.

<Callout type="warning" emoji="⚠️">
  Before we start, please make sure you have created your meteor-app and defined
  the data models you want to use in your app using the [create-meteor-app
  framework](/cli-and-tools/create-meteor-app).
</Callout>

## Prerequisites

### Install JS SDK

```bash
pnpm install @meteor-web3/connector
```

## Using the SDK

### 3 ways to sign in

[Meteor Connector](https://github.com/meteor-web3/meteor-sdk/tree/main/packages/connector/src/provider)(Without UI) and [Meteor Auth Component](https://github.com/meteor-web3/meteor-components/blob/main/src/components/Auth/index.tsx)(With UI) enables 3 methods to sign in with your wallet. `MeteorWalletProvider`, `MeteorSnapProvider`, and `MeteorWebProvider`.

#### Extension Wallet

Meteor Wallet is a browser extension like other crypto wallets. This is the most secure way to run the OS in your browser, and store file encryption keys, app session keys, resource capabilities locally.

<img
  src="/images/introduction/wallets.png"
  width="75%"
  className="mx-auto my-2.5"
/>

#### MetaMask snap

Meteor Snap integrates DataverseOS into Metamask, so users can use their existing wallet to log in personal cloud. After installation, your Metamask will have data wallet functions.

<img
  src="/images/introduction/snap.png"
  width="75%"
  className="mx-auto my-2.5"
/>

#### Web

Meteor Web provides the best user experience. Similar to MPC wallets (e.g. [privy](https://www.privy.io/)), web auth SDK will open an isolated iframe that serves as the interface between app websites and data operating system. Users are not required to download extensions or snaps; simply use their existing asset wallets to sign in smoothly. The session keypair is generated with 128 bits of entropy chosen at random; its private key is never persisted so only users can access in memory.

<img
  src="/images/introduction/web.png"
  width="75%"
  className="mx-auto my-2.5"
/>

### Using Meteor Auth Component

Import the MeteorContextProvider into your project, and wrap your app with it.

Concretely, the MeteorContextProvider must wrap any component or page that will use the Meteor SDK or Meteor Auth Component. It is generally recommended to render it as close to the root of your application as possible.

<Callout type="info">
  If you're new to React and using contexts, check out
  [these](https://react.dev/learn/thinking-in-react)
  [resources](https://react.dev/learn/passing-data-deeply-with-context)!
</Callout>

For example, in a NextJS or Create React App project, you may wrap your components like so:

```javascript
/** Import Meteor Hooks */
import { MeteorContextProvider } from '@meteor-web3/hooks';

export default function Providers({children}: {children: React.ReactNode}) {
  return (
    <MeteorContextProvider autoInit={false}>
      {children}
    </MeteorContextProvider>;
  )
}
```

Once you've wrapped your app with the MeteorContextProvider, you can now use the Meteor SDK throughout your components and pages via the meteor hooks!
If you want to use the Auth Component, you need to use useContext to take out the MeteorContext and pass it to the Auth component in order for the Auth Component and hook to have the same data and status.

```javascript
/** Import Meteor Auth Component */
import { useContext } from 'react';
import { Auth } from '@meteor-web3/components';
import { MeteorContext } from '@meteor-web3/hooks';

const meteorContext = useContext(MeteorContext);

const connectRes = await Auth.openModal(
  {
    appId: process.env.METEOR_APP_ID,
  },
  meteorContext,
);
```

## Step 1: Initialize the connector

```javascript
// After installation, you can import the SDK and initialize the meteor connector.
/** Import Meteor Connector SDK */
import {
  Connector,
  MeteorWalletProvider,
  MeteorWebProvider,
} from '@meteor-web3/connector';

/** Or initialize the meteor connector class object with MeteorWebProvider*/
const connector = new Connector(new MeteorWebProvider());
```

## Step 2: Connect with user wallet

```javascript
import React, { useState } from 'react';

/** Import Meteor Connector SDK and types */
import {
  Connector,
  WALLET,
  MeteorWebProvider
} from "@meteor-web3/connector";

/**
 * Initialize the Meteor Connector
 */
const connector: Connector = new Connector(new MeteorWebProvider());

const App: React.FC = () => {
  const [wallet, setWallet] = useState<WALLET>();

  const connectWallet = async () => {
    try {
      const res = await connector.connectWallet({
        provider: window.ethereum
      });
      setWallet(res.wallet);
      return(res.address);
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <button onClick={connectWallet}>
      Connect Wallet
    </button>
  );
};

export default App;
```

The `connectWallet` function receives an optional parameter `wallet` to specify which wallet to use.

```js
enum WALLET {
  METAMASK = "MetaMask",
  WALLETCONNECT = "WalletConnect",
  COINBASE = "Coinbase",
  PARTICLE = "Particle"
}
```

## Step 3: Create capability

```js
import { RESOURCE } from '@meteor-web3/connector';

const app = 'YOUR_APP_NAME';

const createCapability = async () => {
  const pkh = await connector.runOS({
    method: SYSTEM_CALL.createCapability,
    params: {
      appId,
      resource: RESOURCE.CERAMIC,
      wallet,
    },
  });
  return pkh;
};
```

This will open a popup window to ask for user permission to connect with the application.
We use Sign-in-with-Ethereum signatures to authenticate the user approvement.
The popup shall be like this:

<div className="flex">
  <img src="/images/sdk/siwe1.png" width="50%" />
  <img src="/images/sdk/siwe2.png" width="50%" />
</div>

It returns:
pkh: string - a pkh 'DID' you may use to interact with the data resources later.

## Step 4: Create a file

File is the smallest unit of data in our system.
Unlike IPFS CID which 1. cannot be changed after upload 2. are discrete and not related, files can be updated after creation and linked between each other.
Each file belongs to a data model. For example, if you have created a data model called `post` as a data structure for posts in a social app

```graphql
type post @createModel(accountRelation: LIST, description: "post") {
  author: DID! @documentAccount # DID of the user who created this post
  version: CommitID! @documentVersion
  appVersion: String! @string(maxLength: 100)
  text: String @string(maxLength: 300000000) # text content of the post
  images: [String] @list(maxLength: 10000000) @string(maxLength: 2000000) # images of the post
  videos: [String] @list(maxLength: 10000000) @string(maxLength: 2000000) # videos of the post
  options: String @string(maxLength: 300000000)
  createdAt: DateTime! # time when the post is created
  updatedAt: DateTime! # time when the post is updated
}
```

`createIndexFile` under this `post` model is how you create posts.

```javascript
const encrypted = JSON.stringify({
  text: false,
  images: false,
  videos: false,
});

const res = await connector.runOS({
  method: SYSTEM_CALL.createIndexFile,
  params: {
    modelId,
    fileName: "post1",
    fileContent: {
      modelVersion: "0.0.1",
      text: "hello",
      images: [
        "https://bafkreib76wz6wewtkfmp5rhm3ep6tf4xjixvzzyh64nbyge5yhjno24yl4.ipfs.w3s.link",
      ],
      videos: [],
      createdAt: new Date().toISOString();,
      updatedAt: new Date().toISOString();,
      encrypted,
    },
  },
});
```

return example

```json
{
  "pkh": "did:pkh:eip155:1:0xb4D93398f6F3FB5EE4436D1aE93b32d65693a799",
  "appId": "a3f0ac63-ff7d-4085-aade-c04888b71088",
  "modelId": "kjzl6hvfrbw6catek36h3pep09k9gymfnla9k6ojlgrmwjogvjqg8q3zpybl1yu",
  "fileContent": {
    "content": {
      "text": "hello",
      "images": [
        "https://bafkreib76wz6wewtkfmp5rhm3ep6tf4xjixvzzyh64nbyge5yhjno24yl4.ipfs.w3s.link"
      ],
      "videos": [],
      "createdAt": "2023-11-02T08:04:53.380Z",
      "encrypted": "{\"text\":false,\"images\":false,\"videos\":false}",
      "updatedAt": "2023-11-02T08:04:53.380Z",
      "modelVersion": "0.0.1"
    },
    "file": {
      "fsVersion": "0.11",
      "contentId": "kjzl6kcym7w8y8wx1zuujmssq4wj6o6paynupzmidz7izcsiqwgpnt1uyo9lg2a",
      "contentType": {
        "resource": "CERAMIC",
        "resourceId": "kjzl6hvfrbw6catek36h3pep09k9gymfnla9k6ojlgrmwjogvjqg8q3zpybl1yu"
      },
      "fileName": "create a file",
      "fileType": 0,
      "createdAt": "2023-11-02T08:04:56.699Z",
      "updatedAt": "2023-11-02T08:04:56.699Z",
      "fileId": "kjzl6kcym7w8ya3kyamskljmo181t6z3vz6px0w90c76ea3m28g994t58341ijt"
    }
  }
}
```

<Callout emoji="❗">
  To create a file under a specific model, you need to specify the model id and
  ensure your app has the capability to write data under this model. if not,
  please use `createCapability` to create a capability for the model first.
</Callout>

## Step 5: Load a file

You can load an indexFile's content by its id.

```javascript
await connector.runOS({
  method: SYSTEM_CALL.loadFile,
  params: indexFileId,
});
```

You can also load multiple indexFiles under a model using [`loadFilesBy`](/file/loadFilesBy).

```javascript
await connector.runOS({
  method: SYSTEM_CALL.loadFilesBy,
  params: {
    modelId,
    pkh,
  },
});
```

The `pkh` field is optional. If not specified, it will return all streams under the model. Otherwise, it will return streams under the model that are created by the user.

## Step 6: Update a file

```javascript
const date = new Date().toISOString();

const encrypted = JSON.stringify({
  text: true,
  images: true,
  videos: false,
});

const res = await connector.runOS({
  method: SYSTEM_CALL.updateIndexFile,
  params: {
    fileId,
    fileName: 'new-post1',
    fileContent: {
      appVersion: '0.1.0',
      text: 'hello',
      images: [
        'https://bafkreib76wz6wewtkfmp5rhm3ep6tf4xjixvzzyh64nbyge5yhjno24yl4.ipfs.w3s.link',
      ],
      videos: [],
      createdAt: date,
      updatedAt: date,
      encrypted,
    },
  },
});
```

`updateIndexFile` shares the same parameters as `createIndexFile`, except the `fileId` is required.
and the return value is in the same format as `createIndexFile`.

## Step 7: Monetize a file

```javascript
import { Currency } from "@meteor-web3/connector";

const res = await connector.runOS({
  method: SYSTEM_CALL.monetizeFile,
  params: {
    ...(indexFileId ? { indexFileId } : { streamId }),
    datatokenVars: {
      profileId,
      collectLimit: 100,
      amount: 0.0001,
      currency: Currency.WMATIC,
    },
    decryptionConditions: [
      ...
    ]
  },
});
```

To put it simply, data monetization is to deploy a collection of NFTs on the blockchain
and use the NFT as access credentials to the data. We deployed multi version of smart contracts for this process of converting off-chain data to on-chain NFTs.
By default, leave the `profileId` as `null`, and the transaction will go through meteor default profileless smart contracts.
We're also compatible with [Lens Protocol](https://lens.xyz/) in case you want to use their smart contracts and let your lens handle own your data. Pass in your lens profile id to `profileId` to use Lens Protocol here.

`decryptionConditions` specifies a set of conditions to limit access to the data.
For example

```javascript
[
  {
    conditionType: 'evmBasic',
    contractAddress: '',
    standardContractType: '',
    chain: 'filecoin',
    method: '',
    parameters: [':userAddress'],
    returnValueTest: {
      comparator: '=',
      value: '0x3c6216caE32FF6691C55cb691766220Fd3f55555',
    },
  },
];
```

This condition specifies that the data can only be accessed by the
wallet address `0x3c6216caE32FF6691C55cb691766220Fd3f55555` on filecoin chain.

## Step 8: Purchase a file

```javascript
await connector.runOS({
  method: SYSTEM_CALL.collectFile,
  params: indexFileId,
});
```

This will send a transaction to mint an NFT to the user's wallet address.
The NFT is the access credential to the data.

<Callout>
  `monetizeFile` and `collectFile` functions are on Mumbai testnet for now.
</Callout>

After purchase completed, you can load the file content using `unlockFile` function.

```javascript
await connector.runOS({
  method: SYSTEM_CALL.unlockFile,
  params: indexFileId,
});
```

s
